MOBX presentation
=================

sources:
========
https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254

1. Observable state.
Any value that can be mutated and might serve as source for computed values is state.
MobX can make most types of values (primitives, arrays, classes, objects, etc.) and
even (potentially cyclic) references observable out of the box.

2. Computed values. Any value that can be computed by using a function that purely
operates on other observable values. Computed values can range from the concatenation
of a few strings up to deriving complex object graphs and visualizations.
Because computed values are observable themselves, even the rendering of a complete
user interface can be derived from the observable state. Computed values might
evaluate either lazily or in reaction to state changes.

3. Reactions. A reaction is a bit similar to a computed value, but instead of
producing a new value it produces a side effect. Reactions bridge reactive and
imperative programming for things like printing to the console, making network
requests, incrementally updating the React component tree to patch the DOM, etc.

4. Actions. Actions are the primary means to modify the state. Actions are not a
reaction to state changes but take sources of change, like user events or incoming
web-socket connections, to modify the observable state.


Computed values and reactions are both referred to as derivations in the remainder of this blog-post.
So far, this might all sound a bit academic so letâ€™s make it concrete! In a spreadsheet
all data cells that have values would form the observable state. Formulas and charts
are computed values that can be derived from the data cells and other formulas.
Drawing the output of a data cell or a formula on the screen is a reaction.
Changing a data cell or formula is an action.


http://www.robinwieruch.de/redux-mobx-confusion/#motivation

http://www.robinwieruch.de/mobx-react/


Mobx solves the below problem
https://github.com/krasimir/react-in-patterns/tree/master/patterns/one-direction-data-flow

Service communicating
with our backend
    ^
    |
    v
  Store <-----
    |        |
    v        |
Switcher ---->
    ^
    |
    |
User input

The benefit that comes with this pattern is that our components become dummy representation
of the Store's data. It's really easy to think about the React components as views (renderers).
We write our application in a declarative way and deal with the complexity in only one place.


http://aeflash.com/2015-02/react-tips-and-best-practices.html


http://www.robinwieruch.de/tips-to-learn-react-redux/
